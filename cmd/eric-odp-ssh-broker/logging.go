package main

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log"
	"log/slog"
	"net/http"
	"net/http/pprof"
	"os"
	"path/filepath"

	"eric-odp-ssh-broker/internal/dirwatcher"
)

// LogControl The array of log control items.
type LogControl []*LogControlItems

// LogControlItems A log control entry.
type LogControlItems struct {
	// Name of the image for the container producing the log event.
	Container string `json:"container"`

	// Optional list of log events customized filters.
	// eg. to log events generated by a specific POD, class, package, thread, etc.
	CustomFilters []interface{} `json:"customFilters,omitempty"`

	// Log event severity level.
	Severity string `json:"severity"`
}

var (
	errMissingSchemaJSONFields = errors.New("missing \"container\" or \"severity\" field")
	programLevel               = new(slog.LevelVar) // Info by default
	ctlFileInPlainDir          = false
	debugEnabled               = false
	debugMux                   http.ServeMux
)

func initLogging() {
	var logWriter io.Writer = os.Stderr
	if appConfig.LogFile != "" {
		var err error
		logWriter, err = NewRollingLogAppender(appConfig.LogFile, appConfig.LogFileWrites)
		if err != nil {
			log.Fatalf("Could not initialise logging: %v", err)
		}
	}
	h := slog.NewJSONHandler(logWriter, &slog.HandlerOptions{Level: programLevel})
	slog.SetDefault(slog.New(h).With("service_id", ServiceID, "version", Version))

	if appConfig.LogControlFile != "" {
		reloadConfiguration()

		ctlFileDir := filepath.Dir(appConfig.LogControlFile)
		dotDotDataFile := filepath.Join(ctlFileDir, "..data")
		if _, err := os.Stat(dotDotDataFile); errors.Is(err, os.ErrNotExist) {
			ctlFileInPlainDir = true
		}
		if err := dirwatcher.WatchDirectory(ctlFileDir, dirWatchHandler); err != nil {
			log.Fatalf("Failed to set dirwatcher for %s: %v", ctlFileDir, err)
		}
	}

	debugMux := http.NewServeMux()

	debugMux.HandleFunc("/debug/pprof/", pprof.Index)
	debugMux.HandleFunc("/debug/pprof/cmdline", pprof.Cmdline)
	debugMux.HandleFunc("/debug/pprof/profile", pprof.Profile)
	debugMux.HandleFunc("/debug/pprof/symbol", pprof.Symbol)
	debugMux.Handle("/debug/pprof/goroutine", pprof.Handler("goroutine"))
	debugMux.Handle("/debug/pprof/heap", pprof.Handler("heap"))
	debugMux.Handle("/debug/pprof/threadcreate", pprof.Handler("threadcreate"))
	debugMux.Handle("/debug/pprof/block", pprof.Handler("block"))
}

func handleDebug(w http.ResponseWriter, r *http.Request) {
	slog.Info("handleDebug", "debugEnabled", debugEnabled, "request.URL.Path", r.URL.Path)
	if debugEnabled {
		if r.URL.Path == "/debug/pprof/goroutine" {
			pprof.Handler("goroutine").ServeHTTP(w, r)
		} else {
			debugMux.ServeHTTP(w, r)
		}
	} else {
		w.WriteHeader(http.StatusForbidden)
	}
}

func unmarshalJSON(data []byte, logControl *LogControl) error {
	if err := json.Unmarshal(data, &logControl); err != nil {
		return fmt.Errorf("json unmarshal error: %w", err)
	}
	missingField := false
	for _, v := range *logControl {
		if v.Container == "" {
			missingField = true
		}
		if v.Severity == "" {
			missingField = true
		}
	}
	if missingField {
		return errMissingSchemaJSONFields
	}

	return nil
}

func getLogControl(fileName string) (LogControl, error) {
	data, err := os.ReadFile(fileName)
	if err != nil {
		return nil, fmt.Errorf("get log control read file error: %w", err)
	}
	var logControl LogControl
	err = unmarshalJSON(data, &logControl)
	if err != nil {
		return nil, err
	}
	slog.Info("loaded config file", "logfile", fileName, "logconfig", logControl)

	return logControl, nil
}

func reloadConfiguration() {
	logConfig, err := getLogControl(appConfig.LogControlFile)
	if err != nil {
		slog.Error("unable to reload log config", "err", err)

		return
	}

	// Only setting we have now is logLevel
	for _, entry := range logConfig {
		if entry.Container != ServiceID {
			continue
		}

		var newLevel slog.Level
		if err = newLevel.UnmarshalText([]byte(entry.Severity)); err != nil {
			slog.Error("Failed to decode Severity", "Severity", entry.Severity)
		}
		slog.Info("Updating program level", "programLevel", programLevel, "newLevel", newLevel)
		programLevel.Set(newLevel)

		debugEnabled = newLevel == slog.LevelDebug
	}

	slog.Info("Updated log configuration, reloaded log config", "logConfig", logConfig)
}

func dirWatchHandler(path string, op uint32) {
	slog.Info("dirWatchHandler", "path", path, "op", op)

	reloadRequired := false

	fileName := filepath.Base(path)
	if !ctlFileInPlainDir && fileName == "..data" && ((op & dirwatcher.Create) == dirwatcher.Create) {
		reloadRequired = true
	} else if ctlFileInPlainDir && path == appConfig.LogControlFile &&
		((op & (dirwatcher.Create | dirwatcher.Write)) != 0) {
		reloadRequired = true
	}

	if reloadRequired {
		reloadConfiguration()
	} else {
		slog.Info("reload not required")
	}
}
